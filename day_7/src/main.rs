// From https://adventofcode.com/2025/day/7

// --- Day 7: Laboratories ---

// You thank the cephalopods for the help and exit the trash compactor, finding
// yourself in the familiar halls of a North Pole research wing.

// Based on the large sign that says "teleporter hub", they seem to be
// researching teleportation; you can't help but try it for yourself and step
// onto the large yellow teleporter pad.

// Suddenly, you find yourself in an unfamiliar room! The room has no doors; the
// only way out is the teleporter. Unfortunately, the teleporter seems to be
// leaking magic smoke.

// Since this is a teleporter lab, there are lots of spare parts, manuals, and
// diagnostic equipment lying around. After connecting one of the diagnostic
// tools, it helpfully displays error code 0H-N0, which apparently means that
// there's an issue with one of the tachyon manifolds.

// You quickly locate a diagram of the tachyon manifold (your puzzle input).
// A tachyon beam enters the manifold at the location marked S; tachyon beams
// always move downward. Tachyon beams pass freely through empty space (.).
// However, if a tachyon beam encounters a splitter (^), the beam is stopped;
// instead, a new tachyon beam continues from the immediate left and from the
// immediate right of the splitter.

// For example:

// .......S.......
// ...............
// .......^.......
// ...............
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............

// In this example, the incoming tachyon beam (|) extends downward from S until
// it reaches the first splitter:

// .......S.......
// .......|.......
// .......^.......
// ...............
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............

// At that point, the original beam stops, and two new beams are emitted from
// the splitter:

// .......S.......
// .......|.......
// ......|^|......
// ...............
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............

// Those beams continue downward until they reach more splitters:

// .......S.......
// .......|.......
// ......|^|......
// ......|.|......
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............

// At this point, the two splitters create a total of only three tachyon beams,
// since they are both dumping tachyons into the same place between them:

// .......S.......
// .......|.......
// ......|^|......
// ......|.|......
// .....|^|^|.....
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............

// This process continues until all of the tachyon beams reach a splitter or
// exit the manifold:

// .......S.......
// .......|.......
// ......|^|......
// ......|.|......
// .....|^|^|.....
// .....|.|.|.....
// ....|^|^|^|....
// ....|.|.|.|....
// ...|^|^|||^|...
// ...|.|.|||.|...
// ..|^|^|||^|^|..
// ..|.|.|||.|.|..
// .|^|||^||.||^|.
// .|.|||.||.||.|.
// |^|^|^|^|^|||^|
// |.|.|.|.|.|||.|

// To repair the teleporter, you first need to understand the beam-splitting
// properties of the tachyon manifold. In this example, a tachyon beam is split
// a total of 21 times.

// Analyze your manifold diagram. How many times will the beam be split?

// --- Part Two ---

// With your analysis of the manifold complete, you begin fixing the teleporter.
// However, as you open the side of the teleporter to replace the broken
// manifold, you are surprised to discover that it isn't a classical tachyon
// manifold - it's a quantum tachyon manifold.

// With a quantum tachyon manifold, only a single tachyon particle is sent
// through the manifold. A tachyon particle takes both the left and right path
// of each splitter encountered.

// Since this is impossible, the manual recommends the many-worlds
// interpretation of quantum tachyon splitting: each time a particle reaches a
// splitter, it's actually time itself which splits. In one timeline, the
// particle went left, and in the other timeline, the particle went right.

// To fix the manifold, what you really need to know is the number of timelines
// active after a single particle completes all of its possible journeys through
// the manifold.

// In the above example, there are many timelines. For instance, there's the
// timeline where the particle always went left:

// .......S.......
// .......|.......
// ......|^.......
// ......|........
// .....|^.^......
// .....|.........
// ....|^.^.^.....
// ....|..........
// ...|^.^...^....
// ...|...........
// ..|^.^...^.^...
// ..|............
// .|^...^.....^..
// .|.............
// |^.^.^.^.^...^.
// |..............

// Or, there's the timeline where the particle alternated going left and right
// at each splitter:

// .......S.......
// .......|.......
// ......|^.......
// ......|........
// ......^|^......
// .......|.......
// .....^|^.^.....
// ......|........
// ....^.^|..^....
// .......|.......
// ...^.^.|.^.^...
// .......|.......
// ..^...^|....^..
// .......|.......
// .^.^.^|^.^...^.
// ......|........

// Or, there's the timeline where the particle ends up at the same point as the
// alternating timeline, but takes a totally different path to get there:

// .......S.......
// .......|.......
// ......|^.......
// ......|........
// .....|^.^......
// .....|.........
// ....|^.^.^.....
// ....|..........
// ....^|^...^....
// .....|.........
// ...^.^|..^.^...
// ......|........
// ..^..|^.....^..
// .....|.........
// .^.^.^|^.^...^.
// ......|........

// In this example, in total, the particle ends up on 40 different timelines.

// Apply the many-worlds interpretation of quantum tachyon splitting to your
// manifold diagram. In total, how many different timelines would a single
// tachyon particle end up on?

use std::{collections::HashMap, io::BufRead};

fn part1_solver(lines: &[String]) {
    let width: usize = lines.iter().map(|l| l.len()).max().unwrap_or(0);
    let mut beams_pos: Vec<usize> = vec![];
    let mut nb_splitting: u64 = 0;

    for line in lines {
        if beams_pos.is_empty() {
            println!("{line}");
            let Some(start_pos) = line.find("S") else {
                panic!("No start found!");
            };
            beams_pos.push(start_pos);
        } else {
            let mut new_line = line.clone();
            for (pos, cell) in line.chars().enumerate() {
                if cell == '^' && beams_pos.contains(&pos) {
                    if pos > 0 && !beams_pos.contains(&(pos - 1)) {
                        beams_pos.push(pos - 1);
                        new_line.replace_range((pos - 1)..pos, "|");
                    }
                    if pos < width - 1 && !beams_pos.contains(&(pos + 1)) {
                        beams_pos.push(pos + 1);
                        new_line.replace_range((pos + 1)..(pos + 2), "|");
                    }
                    let Some(beam_idx) = beams_pos.iter().position(|p| *p == pos) else {
                        panic!("Can't retrieve position of current beam in the list!");
                    };
                    beams_pos.remove(beam_idx);
                    nb_splitting += 1;
                } else if beams_pos.contains(&pos) {
                    new_line.replace_range(pos..(pos + 1), "|");
                }
            }
            println!("{new_line}");
        }
    }
    println!("[PART 1] Beam has been splited {nb_splitting} times");
}

fn travel_tree(
    lines: &[String],
    row: usize,
    beam_pos: usize,
    memo: &mut HashMap<(usize, usize), u64>,
    width: usize,
) -> u64 {
    if row >= lines.len() {
        return 1;
    }

    if let Some(&result) = memo.get(&(row, beam_pos)) {
        return result;
    }

    let current_line = &lines[row];
    let mut count = 0;
    if current_line.chars().nth(beam_pos) == Some('^') {
        if beam_pos + 1 < width {
            count += travel_tree(lines, row + 1, beam_pos + 1, memo, width);
        }
        if beam_pos > 0 {
            count += travel_tree(lines, row + 1, beam_pos - 1, memo, width);
        }
    } else {
        count = travel_tree(lines, row + 1, beam_pos, memo, width)
    };

    memo.insert((row, beam_pos), count);
    count
}

fn part2_solver(lines: &[String]) {
    let width: usize = lines.iter().map(|l| l.len()).max().unwrap_or(0);
    let Some(beam_start) = lines[0].find("S") else {
        panic!("No start found");
    };
    let mut memo = HashMap::new();
    let nb_alternative_timelines = travel_tree(lines, 1, beam_start, &mut memo, width);
    println!("[PART 2] Number of alternative timelines {nb_alternative_timelines}");
}

fn main() {
    let Ok(file) = std::fs::File::open("input.txt") else {
        panic!("Failed to open file: `input.txt`");
    };

    let reader = std::io::BufReader::new(file);
    let lines: Vec<String> = reader.lines().map(|l| l.unwrap()).collect();

    part1_solver(&lines);
    part2_solver(&lines);
}
